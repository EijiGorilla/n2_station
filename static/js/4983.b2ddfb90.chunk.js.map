{"version":3,"file":"static/js/4983.b2ddfb90.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/src/components/tree/utils.ts","../node_modules/@esri/calcite-components/dist/components/src/components/tree/tree.scss?tag=calcite-tree&encapsulation=shadow","../node_modules/@esri/calcite-components/dist/components/src/components/tree/tree.tsx"],"sourcesContent":["export function isTreeItem(element: Element): element is HTMLCalciteTreeItemElement {\n  return element?.tagName === \"CALCITE-TREE-ITEM\";\n}\n\nexport function getTraversableItems(root: HTMLCalciteTreeElement): HTMLCalciteTreeItemElement[] {\n  return Array.from(root.querySelectorAll<HTMLCalciteTreeItemElement>(\"calcite-tree-item:not([disabled])\")).filter(\n    (item): boolean => {\n      let currentItem: HTMLElement = item;\n\n      while (currentItem !== root && currentItem !== undefined) {\n        const parent = currentItem.parentElement;\n        const traversable = !isTreeItem(parent) || !parent.hasChildren || parent.expanded;\n\n        if (!traversable) {\n          return false;\n        }\n\n        currentItem = currentItem.parentElement;\n      }\n\n      return true;\n    },\n  );\n}\n",":host {\n  @apply block;\n}\n\n:host(:focus) {\n  @apply outline-none;\n}\n\n@include base-component();\n","import {\n  Component,\n  Element,\n  Event,\n  EventEmitter,\n  h,\n  Host,\n  Listen,\n  Prop,\n  VNode,\n} from \"@stencil/core\";\nimport { focusElement, nodeListToArray, toAriaBoolean } from \"../../utils/dom\";\nimport { Scale, SelectionMode } from \"../interfaces\";\nimport { TreeItemSelectDetail } from \"../tree-item/interfaces\";\nimport { getTraversableItems, isTreeItem } from \"./utils\";\n\n/**\n * @slot - A slot for `calcite-tree-item` elements.\n */\n@Component({\n  tag: \"calcite-tree\",\n  styleUrl: \"tree.scss\",\n  shadow: true,\n})\nexport class Tree {\n  //--------------------------------------------------------------------------\n  //\n  //  Properties\n  //\n  //--------------------------------------------------------------------------\n\n  /** When `true`, displays indentation guide lines. */\n  @Prop({ mutable: true, reflect: true }) lines = false;\n\n  /**\n   * @internal\n   */\n  @Prop({ reflect: true, mutable: true }) child: boolean;\n\n  /** Specifies the size of the component. */\n  @Prop({ mutable: true, reflect: true }) scale: Scale = \"m\";\n\n  /**\n   * Specifies the selection mode of the component, where:\n   *\n   * `\"ancestors\"` displays with a checkbox and allows any number of selections from corresponding parent and child selections,\n   *\n   * `\"children\"` allows any number of selections from one parent from corresponding parent and child selections,\n   *\n   * `\"multichildren\"` allows any number of selections from corresponding parent and child selections,\n   *\n   * `\"multiple\"` allows any number of selections,\n   *\n   * `\"none\"` allows no selections,\n   *\n   * `\"single\"` allows one selection, and\n   *\n   * `\"single-persist\"` allows and requires one selection.\n   *\n   * @default \"single\"\n   */\n  @Prop({ mutable: true, reflect: true }) selectionMode: SelectionMode = \"single\";\n\n  /**\n   * Specifies the component's selected items.\n   *\n   * @readonly\n   */\n  @Prop({ mutable: true }) selectedItems: HTMLCalciteTreeItemElement[] = [];\n\n  //--------------------------------------------------------------------------\n  //\n  //  Lifecycle\n  //\n  //--------------------------------------------------------------------------\n\n  componentWillRender(): void {\n    const parent: HTMLCalciteTreeElement = this.el.parentElement?.closest(\"calcite-tree\");\n    this.lines = parent ? parent.lines : this.lines;\n    this.scale = parent ? parent.scale : this.scale;\n    this.selectionMode = parent ? parent.selectionMode : this.selectionMode;\n    this.child = !!parent;\n  }\n\n  render(): VNode {\n    return (\n      <Host\n        aria-multiselectable={\n          this.child\n            ? undefined\n            : toAriaBoolean(\n                this.selectionMode === \"multiple\" || this.selectionMode === \"multichildren\",\n              )\n        }\n        onKeyDown={this.keyDownHandler}\n        role={!this.child ? \"tree\" : undefined}\n        tabIndex={this.getRootTabIndex()}\n      >\n        <slot />\n      </Host>\n    );\n  }\n\n  //--------------------------------------------------------------------------\n  //\n  //  Event Listeners\n  //\n  //--------------------------------------------------------------------------\n\n  @Listen(\"focus\") onFocus(): void {\n    if (!this.child) {\n      const focusTarget =\n        this.el.querySelector<HTMLCalciteTreeItemElement>(\n          \"calcite-tree-item[selected]:not([disabled])\",\n        ) || this.el.querySelector<HTMLCalciteTreeItemElement>(\"calcite-tree-item:not([disabled])\");\n\n      focusElement(focusTarget);\n    }\n  }\n\n  @Listen(\"focusin\") onFocusIn(event: FocusEvent): void {\n    const focusedFromRootOrOutsideTree =\n      event.relatedTarget === this.el || !this.el.contains(event.relatedTarget as HTMLElement);\n\n    if (focusedFromRootOrOutsideTree) {\n      // gives user the ability to tab into external elements (modifying tabindex property will not work in firefox)\n      this.el.removeAttribute(\"tabindex\");\n    }\n  }\n\n  @Listen(\"focusout\") onFocusOut(event: FocusEvent): void {\n    const willFocusOutsideTree = !this.el.contains(event.relatedTarget as HTMLElement);\n\n    if (willFocusOutsideTree) {\n      this.el.tabIndex = this.getRootTabIndex();\n    }\n  }\n\n  @Listen(\"calciteInternalTreeItemSelect\")\n  onInternalTreeItemSelect(event: CustomEvent<TreeItemSelectDetail>): void {\n    if (this.child) {\n      return;\n    }\n\n    const target = event.target as HTMLCalciteTreeItemElement;\n    const childItems = nodeListToArray(target.querySelectorAll(\"calcite-tree-item\"));\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (this.selectionMode === \"ancestors\") {\n      this.updateAncestorTree(event);\n      return;\n    }\n\n    const isNoneSelectionMode = this.selectionMode === \"none\";\n\n    const shouldSelect =\n      this.selectionMode !== null &&\n      (!target.hasChildren ||\n        (target.hasChildren &&\n          (this.selectionMode === \"children\" || this.selectionMode === \"multichildren\")));\n\n    const shouldDeselectAllChildren = this.selectionMode === \"multichildren\" && target.hasChildren;\n\n    const shouldModifyToCurrentSelection =\n      !isNoneSelectionMode &&\n      event.detail.modifyCurrentSelection &&\n      (this.selectionMode === \"multiple\" || this.selectionMode === \"multichildren\");\n\n    const shouldClearCurrentSelection =\n      !shouldModifyToCurrentSelection &&\n      (((this.selectionMode === \"single\" || this.selectionMode === \"multiple\") &&\n        childItems.length <= 0) ||\n        this.selectionMode === \"children\" ||\n        this.selectionMode === \"multichildren\" ||\n        (this.selectionMode === \"single-persist\" && !target.hasChildren));\n\n    const shouldUpdateExpand =\n      [\"multiple\", \"none\", \"single\", \"single-persist\"].includes(this.selectionMode) &&\n      target.hasChildren;\n\n    const targetItems: HTMLCalciteTreeItemElement[] = [];\n\n    if (shouldSelect) {\n      targetItems.push(target);\n    }\n\n    if (shouldClearCurrentSelection) {\n      const selectedItems = nodeListToArray(\n        this.el.querySelectorAll<HTMLCalciteTreeItemElement>(\"calcite-tree-item[selected]\"),\n      );\n\n      selectedItems.forEach((treeItem) => {\n        if (!targetItems.includes(treeItem)) {\n          treeItem.selected = false;\n        }\n      });\n    }\n\n    if (\n      shouldUpdateExpand &&\n      [\"multiple\", \"none\", \"single\", \"single-persist\"].includes(this.selectionMode)\n    ) {\n      target.expanded = !target.expanded;\n    }\n\n    if (shouldDeselectAllChildren) {\n      childItems.forEach((item) => {\n        item.selected = false;\n        if (item.hasChildren) {\n          item.expanded = false;\n        }\n      });\n    }\n\n    if (shouldModifyToCurrentSelection) {\n      window.getSelection().removeAllRanges();\n    }\n\n    if (shouldModifyToCurrentSelection && target.selected) {\n      targetItems.forEach((treeItem) => {\n        if (!treeItem.disabled) {\n          treeItem.selected = false;\n        }\n      });\n    } else if (!isNoneSelectionMode) {\n      targetItems.forEach((treeItem) => {\n        if (!treeItem.disabled) {\n          treeItem.selected = this.selectionMode !== \"single\" || !treeItem.selected;\n        }\n      });\n    }\n\n    this.selectedItems = isNoneSelectionMode\n      ? []\n      : nodeListToArray(this.el.querySelectorAll(\"calcite-tree-item\")).filter((i) => i.selected);\n\n    this.calciteTreeSelect.emit();\n\n    event.stopPropagation();\n  }\n\n  private keyDownHandler = (event: KeyboardEvent): void => {\n    if (this.child) {\n      return;\n    }\n\n    const root = this.el;\n    const target = event.target as HTMLCalciteTreeItemElement;\n\n    const supportedKeys = [\"ArrowRight\", \"ArrowDown\", \"ArrowLeft\", \"ArrowUp\", \"Home\", \"End\", \"Tab\"];\n\n    if (!(isTreeItem(target) && this.el.contains(target)) || !supportedKeys.includes(event.key)) {\n      return;\n    }\n\n    const traversableItems = getTraversableItems(root);\n\n    if (event.key === \"Tab\") {\n      // root tabindex will be restored when blurred/focused\n      traversableItems.forEach((item) => (item.tabIndex = -1));\n      return;\n    }\n\n    if (event.key === \"ArrowDown\") {\n      const currentItemIndex = traversableItems.indexOf(target);\n      const nextItem = traversableItems[currentItemIndex + 1];\n      nextItem?.focus();\n      event.preventDefault();\n      return;\n    }\n\n    if (event.key === \"ArrowUp\") {\n      const currentItemIndex = traversableItems.indexOf(target);\n      const previousItem = traversableItems[currentItemIndex - 1];\n      previousItem?.focus();\n      event.preventDefault();\n      return;\n    }\n\n    if (event.key === \"ArrowLeft\") {\n      if (target.hasChildren && target.expanded) {\n        target.expanded = false;\n        event.preventDefault();\n        return;\n      }\n\n      const rootToItemPath = traversableItems.slice(0, traversableItems.indexOf(target)).reverse();\n      const parentItem = rootToItemPath.find((item) => item.depth === target.depth - 1);\n\n      parentItem?.focus();\n      event.preventDefault();\n\n      return;\n    }\n\n    if (event.key === \"ArrowRight\") {\n      if (!target.disabled && target.hasChildren) {\n        if (!target.expanded) {\n          target.expanded = true;\n          event.preventDefault();\n        } else {\n          const currentItemIndex = traversableItems.indexOf(target);\n          const nextItem = traversableItems[currentItemIndex + 1];\n          nextItem?.focus();\n          event.preventDefault();\n        }\n      }\n\n      return;\n    }\n\n    if (event.key === \"Home\") {\n      const firstNode = traversableItems.shift();\n      if (firstNode) {\n        firstNode.focus();\n        event.preventDefault();\n      }\n      return;\n    }\n\n    if (event.key === \"End\") {\n      const lastNode = traversableItems.pop();\n      if (lastNode) {\n        lastNode.focus();\n        event.preventDefault();\n      }\n      return;\n    }\n  };\n\n  private updateAncestorTree(event: CustomEvent<TreeItemSelectDetail>): void {\n    const item = event.target as HTMLCalciteTreeItemElement;\n    const updateItem = event.detail.updateItem;\n\n    if (item.disabled || (item.indeterminate && !updateItem)) {\n      return;\n    }\n\n    const ancestors: HTMLCalciteTreeItemElement[] = [];\n    let parent = item.parentElement.closest<HTMLCalciteTreeItemElement>(\"calcite-tree-item\");\n    while (parent) {\n      ancestors.push(parent);\n      parent = parent.parentElement.closest<HTMLCalciteTreeItemElement>(\"calcite-tree-item\");\n    }\n\n    const childItems = Array.from(\n      item.querySelectorAll<HTMLCalciteTreeItemElement>(\"calcite-tree-item:not([disabled])\"),\n    );\n    const childItemsWithNoChildren = childItems.filter((child) => !child.hasChildren);\n    const childItemsWithChildren = childItems.filter((child) => child.hasChildren);\n\n    let futureSelected;\n    if (updateItem) {\n      futureSelected = item.hasChildren ? !(item.selected || item.indeterminate) : !item.selected;\n    } else {\n      futureSelected = item.selected;\n    }\n\n    childItemsWithNoChildren.forEach((el) => {\n      el.selected = futureSelected;\n      el.indeterminate = false;\n    });\n\n    function updateItemState(\n      childItems: HTMLCalciteTreeItemElement[],\n      item: HTMLCalciteTreeItemElement,\n    ): void {\n      const selected = childItems.filter((child) => child.selected);\n      const unselected = childItems.filter((child) => !child.selected);\n\n      item.selected = selected.length === childItems.length;\n      item.indeterminate = selected.length > 0 && unselected.length > 0;\n    }\n\n    childItemsWithChildren.reverse().forEach((el) => {\n      const directChildItems = Array.from(\n        el.querySelectorAll<HTMLCalciteTreeItemElement>(\n          \":scope > calcite-tree > calcite-tree-item\",\n        ),\n      );\n\n      updateItemState(directChildItems, el);\n    });\n\n    if (updateItem) {\n      if (item.hasChildren) {\n        updateItemState(childItems, item);\n      } else {\n        item.selected = futureSelected;\n        item.indeterminate = false;\n      }\n    }\n\n    ancestors.forEach((ancestor) => {\n      const descendants = nodeListToArray(ancestor.querySelectorAll(\"calcite-tree-item\"));\n      const activeDescendants = descendants.filter((el) => el.selected);\n      if (activeDescendants.length === 0) {\n        ancestor.selected = false;\n        ancestor.indeterminate = false;\n        return;\n      }\n\n      const indeterminate = activeDescendants.length < descendants.length;\n      ancestor.indeterminate = indeterminate;\n      ancestor.selected = !indeterminate;\n    });\n\n    this.selectedItems = nodeListToArray(this.el.querySelectorAll(\"calcite-tree-item\")).filter(\n      (i) => i.selected,\n    );\n\n    if (updateItem) {\n      this.calciteTreeSelect.emit();\n    }\n  }\n\n  //--------------------------------------------------------------------------\n  //\n  //  Events\n  //\n  //--------------------------------------------------------------------------\n\n  /**\n   * Fires when the user selects/deselects `calcite-tree-items`.\n   */\n  @Event({ cancelable: false }) calciteTreeSelect: EventEmitter<void>;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Private Properties\n  //\n  //--------------------------------------------------------------------------\n\n  @Element() el: HTMLCalciteTreeElement;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Private Methods\n  //\n  //--------------------------------------------------------------------------\n\n  getRootTabIndex(): number {\n    return !this.child ? 0 : -1;\n  }\n}\n"],"names":["isTreeItem","element","tagName","Tree","proxyCustomElement","HTMLElement","keyDownHandler","event","this","child","root","el","target","contains","includes","key","traversableItems","Array","from","querySelectorAll","filter","item","currentItem","undefined","parent","parentElement","hasChildren","expanded","getTraversableItems","currentItemIndex","indexOf","nextItem","focus","preventDefault","previousItem","parentItem","slice","reverse","find","depth","lastNode","pop","firstNode","shift","disabled","forEach","tabIndex","componentWillRender","_this$el$parentElemen","closest","lines","scale","selectionMode","render","h","Host","toAriaBoolean","onKeyDown","role","getRootTabIndex","onFocus","focusTarget","querySelector","focusElement","onFocusIn","relatedTarget","removeAttribute","onFocusOut","onInternalTreeItemSelect","childItems","nodeListToArray","stopPropagation","updateAncestorTree","isNoneSelectionMode","shouldSelect","shouldDeselectAllChildren","shouldModifyToCurrentSelection","detail","modifyCurrentSelection","shouldClearCurrentSelection","length","shouldUpdateExpand","targetItems","push","treeItem","selected","window","getSelection","removeAllRanges","selectedItems","i","calciteTreeSelect","emit","updateItem","indeterminate","ancestors","childItemsWithNoChildren","childItemsWithChildren","futureSelected","updateItemState","unselected","ancestor","descendants","activeDescendants"],"sourceRoot":""}